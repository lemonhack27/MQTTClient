# 新字符设备驱动原理
## 分配和释放设备号
* 使用 register_chrdev 函数注册字符设备的时候只需要给定一个主设备号即可，但是这样会带来两个问题：
①、需要我们事先确定好哪些主设备号没有使用。
②、会将一个主设备号下的所有次设备号都使用掉，比如现在设置 LED 这个主设备号为
200，那么 0~1048575(2^20-1)这个区间的次设备号就全部都被 LED 一个设备分走了。这样太浪费次设备号了！一个 LED 设备肯定只能有一个主设备号，一个次设备号。
解决这两个问题最好的方法就是在使用设备号的时候向 Linux 内核申请，需要几个就申请几个，由 Linux 内核分配设备可以使用的设备号。
* 没有指定设备号的话就使用如下函数来申请设备号：
```
int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name)
```
* 如果给定了设备的主设备号和次设备号就使用如下所示函数来注册设备号即可：
```
int register_chrdev_region(dev_t from, unsigned count, const char *name)
```
* 参数 from 是要申请的起始设备号，也就是给定的设备号；参数 count 是要申请的数量，一般都是一个；参数 name 是设备名字。
* 注销字符设备之后要释放掉设备号，不管是通过 alloc_chrdev_region 函数还是 register_chrdev_region 函数申请的设备号，统一使用如下释放函数：
```
void unregister_chrdev_region(dev_t from, unsigned count)
```
* 新字符设备驱动下，设备号分配示例代码如下：
```
int major; /* 主设备号 */
int minor; /* 次设备号 */
dev_t devid; /* 设备号 */

if (major) { /* 定义了主设备号 */
    devid = MKDEV(major, 0); /* 大部分驱动次设备号都选择 0 */
    register_chrdev_region(devid, 1, "test");
} else { /* 没有定义设备号 */
    alloc_chrdev_region(&devid, 0, 1, "test"); /* 申请设备号 */
    major = MAJOR(devid); /* 获取分配号的主设备号 */
    minor = MINOR(devid); /* 获取分配号的次设备号 */
}
```
## 新的字符设备注册方法
### 1、字符设备结构
在 Linux 中使用 cdev 结构体表示一个字符设备，cdev 结构体在 include/linux/cdev.h 文件中的定义如下：
```
struct cdev {
    struct kobject kobj;
    struct module *owner;
    const struct file_operations *ops;
    struct list_head list;
    dev_t dev;
    unsigned int count;
} __randomize_layout;
```
* 在 cdev 中有两个重要的成员变量：ops 和 dev，这两个就是字符设备文件操作函数集合file_operations 以及设备号 dev_t。编写字符设备驱动之前需要定义一个 cdev 结构体变量，这个变量就表示一个字符设备，如下所示：
```
struct cdev test_cdev;
```
### 2、cdev_init 函数
* 定义好 cdev 变量以后就要使用 cdev_init 函数对其进行初始化，cdev_init 函数原型如下：
```
void cdev_init(struct cdev *cdev, const struct file_operations *fops)
```
* 参数 cdev 就是要初始化的 cdev 结构体变量，参数 fops 就是字符设备文件操作函数集合。
* 使用 cdev_init 函数初始化 cdev 变量的示例代码如下：
```
struct cdev testcdev;

/* 设备操作函数 */
static struct file_operations test_fops = {
    .owner = THIS_MODULE,
    /* 其他具体的初始项 */
};

testcdev.owner = THIS_MODULE;
cdev_init(&testcdev, &test_fops); /* 初始化 cdev 结构体变量 */
```
### 3、cdev_add 函数
* cdev_add 函数用于向 Linux 系统添加字符设备(cdev 结构体变量)，首先使用 cdev_init 函数完成对 cdev 结构体变量的初始化，然后使用 cdev_add 函数向 Linux 系统添加这个字符设备。
* cdev_add 函数原型如下：
```
int cdev_add(struct cdev *p, dev_t dev, unsigned count)
```
* 参数 p 指向要添加的字符设备(cdev 结构体变量)，参数 dev 就是设备所使用的设备号，参数 count 是要添加的设备数量。加入 cdev_add 函数，内容如下所示：
```
struct cdev testcdev;

/* 设备操作函数 */
static struct file_operations test_fops = {
    .owner = THIS_MODULE,
    /* 其他具体的初始项 */
};

testcdev.owner = THIS_MODULE;
cdev_init(&testcdev, &test_fops); /* 初始化 cdev 结构体变量 */
cdev_add(&testcdev, devid, 1); /* 添加字符设备 */
```
* Linux 内核中大量的字符设备驱动都是采用这种方法向 Linux 内核添加字符设备。如果在加上分配设备号的程序，那么它们就一起实现的就是函数 register_chrdev 的功能。

### 4、cdev_del 函数
* 卸载驱动的时候一定要使用 cdev_del 函数从 Linux 内核中删除相应的字符设备，cdev_del 函数原型如下：
```
void cdev_del(struct cdev *p)
```
* 参数 p 就是要删除的字符设备。
* cdev_del 和 unregister_chrdev_region 这两个函数合起来的功能相当于 unregister_chrdev 函数。

## 自动创建设备节点
* 在传统字符设备驱动里面，我们使用 modprobe 加载驱动程序以后还需要使用命令
“mknod”手动创建设备节点。如何实现自动创建设备节点，在驱动中实现自动创建设备节点的功能以后，使用 modprobe 加载驱动模块成功的话就会自动在/dev 目录下
创建对应的设备文件。
### mdev 机制
